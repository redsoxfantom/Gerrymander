{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red63\green127\blue95;\red127\green0\blue85;\red0\green0\blue192;
}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs22 \cf0 		\cf2 /*\cf0 \
\cf2 		 * sensorManager.registerListener(this,\cf0 \
\cf2 		 * sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),\cf0 \
\cf2 		 * sensorManager.SENSOR_DELAY_NORMAL);\cf0 \
\cf2 		 */\cf0 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\pardirnatural
\cf0 \
\
\pard\pardeftab720
\cf0 			\cf2 /*\cf0 \
\cf2 			 * case Sensor.TYPE_GYROSCOPE:\cf0 \
\cf2 			 * \cf0 \
\cf2 			 * outputX2.setText(Float.toString(event.values[0]));\cf0 \
\cf2 			 * outputY2.setText(Float.toString(event.values[1]));\cf0 \
\cf2 			 * outputZ2.setText(Float.toString(event.values[2]));\cf0 \
\cf2 			 * \cf0 \
\cf2 			 * // composeMessage(event, "Gyroscope"); break;\cf0 \
\cf2 			 */\cf0 \
\
			\cf2 /*\cf0 \
\cf2 			 * case Sensor.TYPE_ACCELEROMETER:\cf0 \
\cf2 			 * \cf0 \
\cf2 			 * // Isolate the force of gravity with the low-pass filter.\cf0 \
\cf2 			 * gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];\cf0 \
\cf2 			 * gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];\cf0 \
\cf2 			 * gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];\cf0 \
\cf2 			 * \cf0 \
\cf2 			 * // Remove the gravity contribution with the high-pass filter.\cf0 \
\cf2 			 * linear_acceleration[0] = event.values[0] - gravity[0];\cf0 \
\cf2 			 * linear_acceleration[1] = event.values[1] - gravity[1];\cf0 \
\cf2 			 * linear_acceleration[2] = event.values[2] - gravity[2];\cf0 \
\cf2 			 * \cf0 \
\cf2 			 * outputX.setText(Float.toString(linear_acceleration[0]));\cf0 \
\cf2 			 * outputY.setText(Float.toString(linear_acceleration[1]));\cf0 \
\cf2 			 * outputZ.setText(Float.toString(linear_acceleration[2]));\cf0 \
\cf2 			 * \cf0 \
\cf2 			 * composeMessage(linear_acceleration, "Accelerometer"); break;\cf0 \
\cf2 			 */\
\
/*\
\cf0 	\cf3 public\cf0  \cf3 boolean\cf0  isDamp(SensorEvent event) \{\
		\cf3 boolean\cf0  res = \cf3 false\cf0 ;\
		\cf3 float\cf0  val = 0.8f;\
		\cf3 if\cf0  ((event.\cf4 values\cf0 [0] > val) || (event.\cf4 values\cf0 [1] > val)\
				|| (event.\cf4 values\cf0 [2] > val)) \{\
			res = \cf3 true\cf0 ;\
		\}\
		\cf3 return\cf0  res;\
	\}\
\
	\cf2 // Deprecated before final use is ironed out... sad\cf0 \
	\cf3 public\cf0  \cf3 float\cf0  clean(\cf3 float\cf0  num) \{\
		\cf3 float\cf0  res = 0;\
\
		\cf3 return\cf0  res;\
	\}\
\
	\cf3 public\cf0  \cf3 double\cf0 [] cleanLinearData(\cf3 float\cf0 [] values) \{\
		\cf3 double\cf0 [] res = \cf3 new\cf0  \cf3 double\cf0 [3];\
\
		\cf3 for\cf0  (\cf3 int\cf0  i = 0; i < res.\cf4 length\cf0 ; i++) \{\
\
			\cf4 outputZ\cf0 .setText(Double.toString(Math.pow(getDelta(), 2)));\
			res[i] = ((0.5f) * values[i] * Math.pow(getDelta(), 2));\
		\}\
		\cf3 return\cf0  res;\
	\}\
	\
	\cf3 public\cf0  \cf3 void\cf0  getVelocity(\cf3 double\cf0 [] acceleration) \{\
		\
		\cf3 for\cf0 (\cf3 int\cf0  i =0; i<acceleration.\cf4 length\cf0 ; i++) \{\
			\cf4 velocity\cf0 [i] += \cf4 velocity\cf0 [i] + (\cf4 lastTime\cf0  * acceleration[i]); \
		\}\
	\}\
\
	\cf3 public\cf0  \cf3 double\cf0  getDelta() \{\
		\cf3 double\cf0  deltaTime = 0;\
		\cf3 long\cf0  currTime = System.nanoTime();\
		\cf3 if\cf0  (\cf4 lastTime\cf0  == 0) \{\
			\cf4 lastTime\cf0  = currTime;\
			\cf3 return\cf0  0;\
		\} \cf3 else\cf0  \{\
			deltaTime = currTime - \cf4 lastTime\cf0 ;\
			\cf4 lastTime\cf0  = currTime;\
			\cf2 //outputZ.setText(Double.toString(deltaTime * 0.000000001));\cf0 \
		\}\
		\
		\cf3 return\cf0  deltaTime * 0.000000001;\
	\}\
*/}